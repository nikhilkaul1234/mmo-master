# Marketing Mix Analysis
# Contact: mgentry@lenovo.com

# Load libraries 
x <- c('scales', 'gridExtra', 'tidyverse', 'readxl', 'dummies', 'plotly', 'broom')
lapply(x, require, character.only = TRUE)

# Load data
df <- read_excel('fake_data.xlsx')

# Set some parameters
channelName = "All" #as.character(unique(df$program)[6])

# If you want to filter your data set, there's a filter for you here
df_1 <- df %>%
  filter(Quarter == 'Q1')

# For an initial plot of the spend vs return data, set the axis length
maxX = 1.05*max(df_1$Spend)
maxY = 1.05*max(df_1$Return)

# Set up data frame for plotting
myPlotDataDF = data.frame(Return = df_1$Return, Spend = df_1$Spend)

# Create a simple scatter plot with ggplot2
simpleScatterPlot <- ggplot(myPlotDataDF, aes(x = Spend, y = Return)) +
  geom_point(color="black") +
  theme(panel.background = element_rect(fill = 'grey85'),
        panel.grid.major = element_line(colour = "white")) +
  coord_cartesian(ylim = c(0,maxY), xlim = c(0,maxX)) +
  scale_x_continuous(labels = dollar) +
  scale_y_continuous(labels = comma) + 
  ggtitle(paste(channelName))

simpleScatterPlot


# Fit a Diminishing Return Curve to the points
## 1. This function returns the sum of squared error between 
##    the original point and the points derived from the curve suggested
Ufun<-function(x, Spend, Return) {
  predictedReturn = x[2] + (x[1] - x[2])*((Spend^x[3])/(x[4] + (Spend^x[3])))
  errorSq = (predictedReturn - Return)^2
  sumSqError = sum(errorSq)
  return(sumSqError)
}

## 2. Set parameters to 'step through' in part #3
##    in the vector c(a,b,c,d):
##    a -> The maximum amount of return that an individual spend could achieve over a long term
##    b -> The minimum amount of return that an individual spend could achieve over a long term
##    c -> Shape of the curve (should probably start at 1)
##    d -> The intercept, or an amount of return that's expected when no spend has occurred
startValVec = c(0,0,1.5,0)
minValVec = c(0,0,1.01,0)
maxValVec = c(1000000000,100,2,1000000000)

# 3. Optimize the diminishing return curve
##  The nlminb() function will find the optimal fit by 
##  stepping through the parameters in step 2
optim.parms<-nlminb(objective=Ufun,start=startValVec,
                    lower=minValVec,
                    upper=maxValVec,
                    control=list(iter.max=100000,eval.max=2000),
                    Spend = df_1$Spend,
                    Return = df_1$Return)
optim.parms

a = optim.parms$par[1]
b = optim.parms$par[2]
c = optim.parms$par[3]
d = optim.parms$par[4]

## What were the optimal params?
a
b
c
d

# 4. Plot the diminishing return curve
## The points that construct the curve have to be computed:

## The spend is on the X axis, so we generate 10k X values to plot
curveDFx = seq(from=0, to=max(df_1$Spend)*2, length.out=10000)
## The return is on the Y axis, and those are generated by our optimized function, given the 10k X values
curveDFy = b+(a-b)*((curveDFx^c)/(d+(curveDFx^c)))
## Construct the dataframe to plot
curveDF = data.frame(Spend = curveDFx, Return = curveDFy)

## For an initial plot of the spend vs return data, set the axis length
maxX = 1.05*max(curveDFx, max(df_1$Spend))
maxY = 1.05*max(curveDFy, max(df_1$Return))

## Assemble the data frames
myPlotDataDF = data.frame(Return = df_1$Return, Spend = df_1$Spend)
optimLineDF = data.frame(Spend = curveDFx, Return = curveDFy)

# 5. Plot the points and the diminishing return curve
scatterPlotPlusFit <- ggplot(myPlotDataDF, aes(x = Spend, y = Return)) +
  geom_point(color="black", shape = 16) +
  theme(panel.background = element_rect(fill = 'grey85'),
        panel.grid.major = element_line(colour = "white")) +
  geom_line(data = optimLineDF, aes(x = Spend, y = Return, color = "darkgreen"))  +
  scale_color_manual(labels = "Optimized ADBUDG Fit",values=c('darkgreen')) +
  theme(legend.title=element_blank(), legend.position = "bottom") +
  coord_cartesian(ylim = c(0,maxY), xlim = c(0,maxX)) +
  scale_x_continuous(labels = dollar) +
  scale_y_continuous(labels = comma) + 
  ggtitle(paste(channelName, "Data & Model Fit", sep = " "))

scatterPlotPlusFit

###########

# For the future, let's create a custom function for the optimized diminishing return curve
adbudgReturn = function(a,b,c,d,Spend){
  adbudgReturn = sum(b+(a-b)*((Spend^c)/(d+(Spend^c))))
  return(adbudgReturn)
}

###########

# Problem 1:

# Let's say we have a goal of achieving $500K in return
returnGoal = 500000
# We can generate a recommendation for 
## 1. How much more $ to allocate, and
## 2. Where to allocate it
increment = 10
oldSpendVec = df_1$Spend
oldReturn = adbudgReturn(a,b,c,d,oldSpendVec)
newSpendVec = oldSpendVec

totalSpend = sum(oldSpendVec)
totalReturn = oldReturn

# This while-loop steps through the function to find the 
# level of spend necessary to achieve the return
while(totalReturn < returnGoal){
  incReturns = NULL
  for(i in 1:length(oldSpendVec)){
    oldSpendTemp = newSpendVec[i]
    newSpendTemp = newSpendVec[i] + increment
    
    oldReturnTemp = b+(a-b)*((oldSpendTemp^c)/(d+(oldSpendTemp^c)))
    newReturnTemp = b+(a-b)*((newSpendTemp^c)/(d+(newSpendTemp^c)))
    
    incReturns[i] = newReturnTemp - oldReturnTemp
    
  }
  
  # Define the winner 'spend' as the current spend plus the optimal incremental spend
  winner = which.max(incReturns)
  newSpendVec[winner] = newSpendVec[winner] + increment
  
  totalSpend = totalSpend + increment
  totalReturn = adbudgReturn(a,b,c,d,newSpendVec)
  
}

newReturnVec = b+(a-b)*((newSpendVec^c)/(d+(newSpendVec^c)))
myRecommendedData = data.frame(#Campaign = myData$Campaign,
  #Channel = myData$Channel,
  Return = newReturnVec,
  Spend = newSpendVec)

sum(myRecommendedData$Spend) # Recommended Spend
sum(myRecommendedData$Return)  # Estimated Return from Recommended Spend
sum(myRecommendedData$Spend)/sum(df_1$Spend) - 1  # % Increase in Spend to get $500K


#  Graph current spend vs recommended spend  #
compareDF = data.frame(Program = rep(df_1$Program,2),
                       spendType = rep(c("Actual Spend","Recommended Spend"),
                                       each=dim(df_1)[1]),
                       Spend = c(df_1$Spend, myRecommendedData$Spend))

barChart <- ggplot(data=compareDF, aes(x=Program, y=Spend, fill=spendType)) +
  geom_bar(stat="identity", color="black", position=position_dodge())+
  scale_fill_manual(values=c('darkred','darkblue'),
                    name = "") +
  scale_y_continuous(name="Spend", labels = dollar) +
  theme(axis.text.x = element_text(angle = 45, hjust = .75)) +
  ggtitle("Breakdown of Spend by Campaign")

barChart

percDiff = (myRecommendedData$Spend - df_1$Spend)/df_1$Spend
summaryDF = data.frame(Program = df_1$Program,
                       actualSpend = dollar_format()(df_1$Spend),
                       recommendedSpend = dollar_format()(myRecommendedData$Spend),
                       percDiff = percent((myRecommendedData$Spend - df_1$Spend)/df_1$Spend))

summaryDF

